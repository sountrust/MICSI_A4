<style>
  body {
    font-family: "Segoe UI", Roboto, Arial, sans-serif;
    color: #222;
    background: #fff;
    line-height: 1.6;
  }
  section {
    background: #fafafa;
    border: 1px solid #ddd;
    border-radius: 10px;
    padding: 1.5em 2em;
    margin: 1em 0;
    box-shadow: 0 2px 8px rgba(0,0,0,0.05);
  }
  h2 {
    color: #0d47a1;
    border-left: 5px solid #1976d2;
    padding-left: 10px;
  }
  h3 { color: #1565c0; margin-top: 1.2em; }
  h4 { color: #0288d1; }
  ul { margin-left: 1.3em; }
  code { background: #f4f4f4; padding: 2px 5px; border-radius: 3px; color: #d6336c; }
  pre { background: #272822; color: #f8f8f2; padding: 10px; border-radius: 6px; overflow-x: auto; }
  table {
    border-collapse: collapse; width: 100%; margin: 1em 0;
  }
  th, td { border: 1px solid #ddd; padding: 8px; }
  th { background-color: #1976d2; color: white; }
  tr:nth-child(even) { background-color: #f9f9f9; }
  .callout {
    display: flex; gap: 10px; align-items: flex-start;
    padding: 10px 15px; border-radius: 8px; margin: 1em 0;
  }
  .callout.warn { background: #fff8e1; border-left: 5px solid #ff9800; }
  .callout.info { background: #e3f2fd; border-left: 5px solid #2196f3; }
  .callout.good { background: #e8f5e9; border-left: 5px solid #4caf50; }
  .small { color: #555; font-size: 0.9em; }
</style>

<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script>mermaid.initialize({ startOnLoad: true, theme: "neutral" });</script>

<section id="sec-1" class="section">
  <h2>1ï¸âƒ£ â€“ Du monolithe aux microservices</h2>

  <blockquote>
    <strong>Une application monolithique</strong> regroupe toutes les fonctionnalitÃ©s dans un seul programme.
  </blockquote>

  <h3>âš™ï¸ CaractÃ©ristiques</h3>
  <ul>
    <li>Une <strong>base de code unique</strong>, un seul processus, un seul cycle de dÃ©ploiement.</li>
    <li>SimplicitÃ© initiale âœ… mais forte <strong>dÃ©pendance interne</strong> âŒ entre les modules.</li>
    <li>Tout changement ou panne impacte <strong>lâ€™ensemble du systÃ¨me</strong>.</li>
  </ul>

  <p>ğŸ“š <strong>Lien recommandÃ© :</strong>
    <a href="https://cloud.google.com/kubernetes-engine/kubernetes-comic/" target="_blank" rel="noopener noreferrer">
      BD Kubernetes par Google Cloud
    </a>
  </p>

  <h3>ğŸ•°ï¸ Historique et contexte dâ€™Ã©volution</h3>
  <ul>
    <li>Architecture <strong>client-serveur</strong></li>
    <li>Mises Ã  jour nÃ©cessitant lâ€™arrÃªt complet du service ğŸ›‘</li>
    <li>ScalabilitÃ© <strong>verticale</strong> (plus de matÃ©riel)</li>
  </ul>

  <h3>ğŸš€ Les causes de lâ€™Ã©volution</h3>
  <ul>
    <li><strong>Complexification</strong> des systÃ¨mes</li>
    <li><strong>Ã‰mergence du web</strong> et besoin dâ€™intÃ©gration</li>
    <li>Nouveaux modÃ¨les <strong>DevOps / CI/CD</strong></li>
  </ul>

  <h3>ğŸŒ Les premiÃ¨res interconnexions</h3>
  <table>
    <thead><tr><th>Technologie</th><th>AnnÃ©e</th><th>Description</th></tr></thead>
    <tbody>
      <tr><td><strong>SOAP</strong></td><td>1999</td><td>Web Services XML (interopÃ©rabilitÃ© initiale)</td></tr>
      <tr><td><strong>REST</strong></td><td>2000</td><td>Communication simple HTTP (JSON / XML)</td></tr>
      <tr><td><strong>gRPC</strong></td><td>2015</td><td>Protocole binaire performant basÃ© sur HTTP/2</td></tr>
    </tbody>
  </table>

  <div class="callout info">ğŸ’¬ Ces standards ont permis la communication entre modules indÃ©pendants, amorÃ§ant la transition vers les microservices.</div>

  <h3>ğŸ” Quâ€™est-ce quâ€™un microservice ?</h3>
  <ul>
    <li>ImplÃ©mente une fonction mÃ©tier unique (ex : facturation, loginâ€¦)</li>
    <li>Sâ€™exÃ©cute <strong>indÃ©pendamment</strong></li>
    <li>PossÃ¨de son propre <strong>cycle de vie</strong></li>
  </ul>

  <h3>ğŸŒ‰ Communication</h3>
  <ul>
    <li>Les microservices Ã©changent via des APIs lÃ©gÃ¨res :</li>
    <ul>
      <li>la <strong>modularitÃ©</strong> du code ğŸ§ </li>
      <li>la <strong>tolÃ©rance aux pannes</strong> âš¡</li>
      <li>la <strong>scalabilitÃ© horizontale</strong> ğŸ“ˆ</li>
    </ul>
  </ul>

  <div class="callout warn">
    âš ï¸ Cette libertÃ© ajoute une <strong>complexitÃ© dâ€™infrastructure</strong> : rÃ©seau, monitoring, orchestrationâ€¦
  </div>

  <h3>ğŸ³ Microservice vs Conteneur</h3>
  <table>
    <thead><tr><th>âŒ Mythe</th><th>âœ”ï¸ RÃ©alitÃ©</th></tr></thead>
    <tbody>
      <tr><td>Un microservice = un conteneur</td>
      <td>Le microservice est une idÃ©e logicielle, le conteneur est un environnement dâ€™exÃ©cution.</td></tr>
    </tbody>
  </table>

  <div class="callout good">
    <strong>Microservice</strong> â†’ concept fonctionnel<br>
    <strong>Conteneur</strong> â†’ mÃ©canisme technique
  </div>

  <h3>ğŸš¢ Pourquoi la conteneurisation est essentielle</h3>
  <ul>
    <li>Environnement portable, standardisÃ©, isolÃ©</li>
    <li>Remplacement plutÃ´t que modification</li>
    <li>InteropÃ©rabilitÃ© multi-plateforme</li>
    <li>DÃ©ploiement simplifiÃ© et rÃ©silient</li>
  </ul>

  <div class="callout info">ğŸ’¡ Ces propriÃ©tÃ©s â€” immutabilitÃ© et interopÃ©rabilitÃ© â€” sont la base du cloud-native orchestrÃ© par Kubernetes.</div>

  <h3>âš ï¸ Limites du modÃ¨le monolithique</h3>
  <ul>
    <li>DifficultÃ© dâ€™Ã©volution et de correction</li>
    <li>ScalabilitÃ© verticale uniquement</li>
    <li>DÃ©ploiement lent et risquÃ©</li>
    <li>Couplage fort entre Ã©quipes et technologies</li>
  </ul>

  <pre><code>java -jar application-complete.jar</code></pre>
  <p>ğŸ§± Un seul binaire contenant API, UI, logique mÃ©tier et donnÃ©es.</p>

  <h3>ğŸ§© Vers la modularitÃ© : lâ€™idÃ©e des microservices</h3>
  <ul>
    <li>Chaque service = code + dÃ©pendances + base de donnÃ©es</li>
    <li>Communication via API (HTTP, gRPC, message bus)</li>
    <li>ScalabilitÃ© horizontale ciblÃ©e</li>
    <li>CI/CD facilitÃ© ğŸ¯</li>
  </ul>

  <h3>ğŸ§  Vue architecturale</h3>
  <table>
    <thead><tr><th>Aspect</th><th>ğŸ§± Monolithe</th><th>ğŸ§© Microservices</th></tr></thead>
    <tbody>
      <tr><td>Couplage</td><td>Fort ğŸ”—</td><td>Faible ğŸ”“</td></tr>
      <tr><td>DÃ©ploiement</td><td>Unique</td><td>IndÃ©pendant</td></tr>
      <tr><td>ScalabilitÃ©</td><td>Verticale</td><td>Horizontale</td></tr>
      <tr><td>RÃ©silience</td><td>Panne globale</td><td>Isolement des pannes</td></tr>
      <tr><td>ComplexitÃ© rÃ©seau</td><td>Faible</td><td>Ã‰levÃ©e âš™ï¸</td></tr>
    </tbody>
  </table>

  <div class="callout info">ğŸ‘‰ Les microservices dÃ©placent la complexitÃ© du code vers lâ€™infrastructure.</div>

  <h3>ğŸ’¡ Exemple visuel</h3>
  <div class="mermaid">
    graph LR
      A[Application monolithique unique] --> B[Modules fortement liÃ©s]
      B --> C[Maintenance difficile]
      A -.â†’ D[Transition microservices]
      D --> E[Services indÃ©pendants]
      E --> F[API REST/gRPC]
  </div>

  <h3>ğŸ§° ProblÃ¨me nouveau : exÃ©cution des services</h3>
  <ul>
    <li>Isolation fiable ğŸ§³</li>
    <li>Communication inter-services ğŸŒ</li>
    <li>Mise Ã  jour sans perturbation â™»ï¸</li>
  </ul>

  <div class="mermaid">
    graph TD
      A[Microservice A] -->|API| B[Microservice B]
      B -->|Message Queue| C[Microservice C]
      C --> D[Base de donnÃ©es]
  </div>

  <p>â¡ï¸ Cela demande un mÃ©canisme dâ€™isolation et de gestion : <strong>virtualisation</strong> ğŸ’» + <strong>conteneurisation</strong> ğŸ§±</p>

  <pre><code># Monolithe initial
java -jar monolith.jar

# Microservice isolÃ©
python3 -m http.server 8080</code></pre>

  <p>â¡ï¸ Ce besoin mÃ¨nera naturellement vers la <strong>virtualisation</strong> et la <strong>conteneurisation</strong>.</p>
</section>
  <h2>2ï¸âƒ£ â€“ Virtualisation : lâ€™isolation matÃ©rielle</h2>

  <p>
    La virtualisation permet dâ€™exÃ©cuter plusieurs environnements sur une mÃªme
    machine physique.
  </p>

  <h3>ğŸ” DÃ©finition</h3>
  <p>
    La virtualisation crÃ©e plusieurs <strong>machines virtuelles (VM)</strong> Ã 
    partir de ressources physiques :
  </p>
  <ul>
    <li>
      Chaque VM possÃ¨de son propre <strong>OS</strong>, mÃ©moire, stockage,
      rÃ©seau.
    </li>
    <li>Un <strong>hyperviseur</strong> gÃ¨re la rÃ©partition des ressources.</li>
  </ul>

  <h3>ğŸ§© Types dâ€™hyperviseurs</h3>

  <h4>Type 1 â€” Bare Metal</h4>
  <ul>
    <li>Fonctionne <strong>directement sur le matÃ©riel</strong>.</li>
    <li>Haute performance et fiabilitÃ©.</li>
    <li>UtilisÃ© dans les <strong>data centers</strong>.</li>
  </ul>
  <p class="small">Exemples : VMware ESXi, Hyper-V, KVM, Xen.</p>

  <h4>Type 2 â€” HÃ©bergÃ©</h4>
  <ul>
    <li>Fonctionne <strong>au-dessus dâ€™un OS hÃ´te</strong>.</li>
    <li>SimplicitÃ© dâ€™installation.</li>
    <li>IdÃ©al pour <strong>tests</strong> ou postes de travail.</li>
  </ul>
  <p class="small">Exemples : VirtualBox, VMware Workstation, Parallels.</p>

  <h3>ğŸ§  RÃ´le de lâ€™hyperviseur</h3>
  <ul>
    <li>Alloue dynamiquement les ressources ğŸ’¾</li>
    <li>Isole les environnements ğŸ”’</li>
    <li>AgrÃ¨ge ou fractionne le matÃ©riel selon les besoins âš™ï¸</li>
  </ul>

  <div class="mermaid">
    graph TD
      A[MatÃ©riel physique (CPU, RAM, disque)] --> B[Hyperviseur]
      B --> C1[VM Linux]
      B --> C2[VM Windows]
      B --> C3[VM Ubuntu]
  </div>

  <h3>âœ… Avantages de la virtualisation</h3>
  <ul>
    <li>Isolation complÃ¨te ğŸ§±</li>
    <li>Mutualisation du matÃ©riel ğŸ’°</li>
    <li>PortabilitÃ© ğŸ§³</li>
    <li>FlexibilitÃ© ğŸ§ </li>
    <li>Abstraction matÃ©rielle ğŸ”Œ</li>
  </ul>

  <p>
    ğŸ’¡ Exemple : un serveur physique hÃ©berge plusieurs VMs (DB, web, stockage).
  </p>

  <h3>âš ï¸ Limites</h3>
  <ul>
    <li>Surcharge mÃ©moire (chaque VM a son OS)</li>
    <li>DÃ©marrage lent ğŸ¢</li>
    <li>Gestion complexe âš™ï¸</li>
  </ul>

  <div class="callout info">â¡ï¸ Naissance de lâ€™<strong>Infrastructure as Code (IaC)</strong> ğŸ’»</div>

  <h3>âš™ï¸ Infrastructure as Code (IaC)</h3>
  <p>
    Lâ€™IaC dÃ©crit lâ€™infrastructure comme du <strong>code dÃ©claratif</strong> :
  </p>
  <ul>
    <li>DÃ©crit lâ€™Ã©tat attendu (VMs, rÃ©seaux, services)</li>
    <li>Automatise la crÃ©ation et la configuration</li>
    <li>Facilite versionnage, reproductibilitÃ©, CI/CD</li>
  </ul>

  <div class="callout good">
    ğŸ§° Outils : Terraform, OpenTofu, Ansible, Puppet, Chef, CloudFormation,
    Pulumi.
  </div>

  <h3>ğŸ³ De la virtualisation Ã  la conteneurisation</h3>
  <p>
    La conteneurisation <strong>ne remplace pas</strong> la virtualisation ;
    elle <strong>sâ€™appuie dessus</strong> :
  </p>
  <ul>
    <li>Les VMs assurent <strong>lâ€™isolation matÃ©rielle</strong> ğŸ”’</li>
    <li>Les conteneurs assurent <strong>lâ€™isolation logicielle</strong> ğŸ§©</li>
  </ul>

  <div class="mermaid">
    graph LR
      A[MatÃ©riel] --> B[Hyperviseur]
      B --> C[VMs]
      C --> D[Conteneurs exÃ©cutÃ©s dans les VMs]
  </div>

  <div class="callout info">ğŸ’¡ Kubernetes combine la robustesse des VMs et la lÃ©gÃ¨retÃ© des conteneurs.</div>

  <h2>3ï¸âƒ£ â€“ Conteneurisation : lâ€™isolation logique</h2>
  <p>
    <em>But :</em> Comprendre comment la conteneurisation isole les processus
    applicatifs dans un mÃªme systÃ¨me dâ€™exploitation, prÃ©pare la modularisation
    des applications et introduit la logique dâ€™orchestration.
  </p>

  <h3>ğŸ§  DÃ©finition & objectifs</h3>
  <p>
    Un <strong>conteneur</strong> = un <strong>processus isolÃ©</strong> + son
    environnement dâ€™exÃ©cution minimal (bibliothÃ¨ques, configuration,
    dÃ©pendances). Contrairement Ã  une VM, il partage le noyau du systÃ¨me hÃ´te,
    ce qui le rend lÃ©ger et rapide.
  </p>

  <div class="callout good">
    ğŸ¯ Objectifs : PortabilitÃ©, ImmutabilitÃ©, RapiditÃ© et DensitÃ©.
  </div>

  <h3>ğŸ§© MÃ©canismes Linux</h3>
  <ul>
    <li>
      <strong>Namespaces</strong> â†’ isolent les espaces dâ€™exÃ©cution :
      <code>pid</code>, <code>net</code>, <code>mnt</code>, <code>uts</code>,
      <code>ipc</code>, <code>user</code>.
    </li>
    <li><strong>cgroups</strong> â†’ contrÃ´lent CPU, mÃ©moire, I/O, etc.</li>
    <li><strong>UnionFS / OverlayFS</strong> â†’ superposent les couches.</li>
    <li><strong>Capabilities / seccomp / AppArmor</strong> â†’ restreignent les appels systÃ¨me.</li>
  </ul>

  <div class="callout info">
    ğŸ’¡ Ces mÃ©canismes sont utilisÃ©s par Docker, Podman, containerd sous le capot.
  </div>

  <h3>ğŸ§± Image et exÃ©cution</h3>
  <pre><code># Exemple : image NGINX
sudo docker run -d -p 8080:80 nginx:1.25
curl http://localhost:8080
  </code></pre>

  <p>â¡ï¸ Le conteneur expose un service HTTP isolÃ©, sans affecter lâ€™hÃ´te.</p>

  <div class="mermaid">
    graph TD
      A[Image Docker]
      B[Conteneur exÃ©cutÃ©]
      C[Application web isolÃ©e]
      A --> B --> C
  </div>

  <h3>ğŸ§° Dockerfile : construction dâ€™une image</h3>
  <pre><code># Exemple : application minimale Node.js
FROM node:20-slim
WORKDIR /app
COPY package*.json ./
RUN npm install --only=production
COPY . .
EXPOSE 5000
CMD ["npm","start"]
  </code></pre>

  <div class="callout good">
    ğŸ§© Lâ€™image devient un artefact versionnÃ© et partageable (Docker Hub, GitLab Registryâ€¦)
  </div>

  <h3>âš™ï¸ Composition de services (Docker Compose)</h3>
  <pre><code>version: "3.9"
services:
  web:
    build: .
    ports:
      - "5000:5000"
    depends_on:
      - db
  db:
    image: postgres:15
volumes:
  data:
  </code></pre>

  <div class="callout info">
    ğŸ§© Compose introduit la dÃ©claration dâ€™un Ã©tat attendu â€” prÃ©misse du modÃ¨le dÃ©claratif Kubernetes.
  </div>

  <h3>ğŸ”’ Bonnes pratiques</h3>
  <ul>
    <li>Images minimales (alpine, distroless)</li>
    <li>Pas dâ€™exÃ©cution en root</li>
    <li>Configuration externalisÃ©e</li>
    <li>Volumes pour la persistance</li>
    <li>Versionner et stocker les images en registre privÃ©</li>
  </ul>

  <h3>ğŸ” ParallÃ¨le Docker Compose â†”ï¸ Kubernetes</h3>
  <table>
    <thead><tr><th>Concept</th><th>Docker Compose</th><th>Kubernetes</th></tr></thead>
    <tbody>
      <tr><td>Service</td><td>DÃ©finit un conteneur et ses dÃ©pendances</td><td>Pod / Deployment</td></tr>
      <tr><td>Port mapping</td><td>ports:</td><td>containerPort / Service</td></tr>
      <tr><td>Volumes</td><td>volumes:</td><td>PersistentVolumeClaim</td></tr>
      <tr><td>Variables</td><td>environment:</td><td>env:</td></tr>
      <tr><td>RÃ©seau</td><td>bridge interne</td><td>CNI</td></tr>
      <tr><td>Fichier</td><td>docker-compose.yml</td><td>YAML manifestes</td></tr>
    </tbody>
  </table>

  <div class="callout good">
    ğŸ’¡ Kubernetes gÃ©nÃ©ralise et distribue ces concepts Ã  grande Ã©chelle (multi-nÅ“uds, auto-guÃ©rison).
  </div>

  <h3>ğŸ§­ Ã€ retenir</h3>
  <ul>
    <li>Un conteneur isole un processus sur le mÃªme noyau Linux.</li>
    <li>Docker/Podman reposent sur namespaces + cgroups.</li>
    <li>Docker Compose introduit la logique dÃ©clarative.</li>
    <li>Cette complexitÃ© mÃ¨ne naturellement Ã  Kubernetes.</li>
  </ul>
  <h2>4ï¸âƒ£ â€“ Kubernetes : orchestrer les conteneurs virtualisÃ©s</h2>

  <p>Quand plusieurs conteneurs doivent coopÃ©rer :</p>
  <ul>
    <li>Automatiser les dÃ©ploiements âš™ï¸</li>
    <li>GÃ©rer le rÃ©seau et les dÃ©pendances ğŸŒ</li>
    <li>Assurer la tolÃ©rance aux pannes ğŸ’ª</li>
    <li>Monter en charge ğŸ“ˆ</li>
  </ul>

  <p>
    â¡ï¸ Apparition des orchestrateurs : Docker Swarm, Mesos,
    <strong>Kubernetes</strong> ğŸš€
  </p>

  <h3>ğŸ§  Orchestration & Kubernetes â€” "Ã©tat dÃ©sirÃ©" et rÃ©conciliation</h3>
  <p>
    <strong>Objectif :</strong> comprendre comment Kubernetes orchestre des
    applications conteneurisÃ©es avec un modÃ¨le dÃ©claratif (Â« Ã©tat dÃ©sirÃ© Â») et
    des boucles de rÃ©conciliation. DÃ©couvrir les objets clÃ©s : <em>Pod,
    Deployment, Service, Ingress</em>.
  </p>

  <h3>ğŸ¯ RÃ©sultats dâ€™apprentissage</h3>
  <ul>
    <li>Expliquer le principe dÃ©claratif : on dÃ©crit <em>ce quâ€™on veut</em>.</li>
    <li>DÃ©crire le cycle <strong>rÃ©conciliation â†’ action â†’ observation</strong>.</li>
    <li>Identifier les composants : API Server, etcd, Scheduler, Controllers, Kubelet, Runtime.</li>
    <li>Lire/Ã©crire des manifestes YAML (Pods / Deployments / Services / Ingress).</li>
    <li>Comprendre le scaling et lâ€™auto-guÃ©rison (remplacement automatique de Pods).</li>
  </ul>

  <h3>ğŸ§© DÃ©claratif vs impÃ©ratif</h3>
  <ul>
    <li><strong>ImpÃ©ratif :</strong> â€œfais ceci, puis celaâ€ â†’ fragile.</li>
    <li><strong>DÃ©claratif :</strong> â€œvoici lâ€™Ã©tat souhaitÃ©â€ â†’ Kubernetes le maintient.</li>
  </ul>

  <p>
    ParallÃ¨le IaC : Terraform dÃ©crit lâ€™infra ; Kubernetes dÃ©crit lâ€™Ã©tat applicatif au niveau service.
  </p>

  <h3>ğŸ” Boucle de rÃ©conciliation (vue systÃ¨me)</h3>
  <div class="mermaid">
    flowchart LR
      subgraph Dev["DÃ©veloppeur"]
        A["Manifeste YAML : Ã©tat dÃ©sirÃ©"]
      end
      A -->|"kubectl apply"| B["API Server"]
      B --> C["etcd (Ã©tat dÃ©sirÃ©)"]
      B --> D[Controllers]
      D --> E{Ã‰tat rÃ©el conforme ?}
      E -- "Non" --> F["CrÃ©er / Remplacer / Scaler Pods"]
      F --> G["Kubelet sur les nÅ“uds"]
      G --> H["Containers (containerd / CRI-O)"]
      H --> I["Rapport dâ€™Ã©tat"]
      I --> D
      E -- "Oui" --> J[Convergence atteinte]
  </div>

  <h3>ğŸ§± Objets fondamentaux</h3>
  <ul>
    <li><strong>Pod</strong> â†’ plus petite unitÃ© dÃ©ployable (1+ conteneurs).</li>
    <li><strong>ReplicaSet</strong> â†’ garantit n copies identiques dâ€™un Pod.</li>
    <li><strong>Deployment</strong> â†’ gÃ¨re le cycle de dÃ©ploiement (rolling update, rollback).</li>
    <li><strong>Service</strong> â†’ point dâ€™accÃ¨s rÃ©seau stable.</li>
    <li><strong>Ingress</strong> â†’ expose les Services via HTTP(S).</li>
    <li><strong>Namespace</strong> â†’ cloisonnement logique.</li>
    <li><strong>ConfigMap / Secret</strong> â†’ configuration et donnÃ©es sensibles.</li>
  </ul>

  <h3>ğŸ“„ Pod minimal</h3>
  <pre><code>apiVersion: v1
kind: Pod
metadata:
  name: demo-pod
spec:
  containers:
    - name: web
      image: nginx:1.25
      ports:
        - containerPort: 80
  </code></pre>

  <h3>ğŸ“¦ Deployment (3 rÃ©plicas)</h3>
  <pre><code>apiVersion: apps/v1
kind: Deployment
metadata:
  name: web-deploy
spec:
  replicas: 3
  selector:
    matchLabels:
      app: web
  template:
    metadata:
      labels:
        app: web
    spec:
      containers:
        - name: web
          image: nginx:1.25
          ports:
            - containerPort: 80
  </code></pre>

  <h3>ğŸŒ Service + Ingress</h3>
  <pre><code>apiVersion: v1
kind: Service
metadata:
  name: web-svc
spec:
  type: ClusterIP
  selector:
    app: web
  ports:
    - port: 80
      targetPort: 80
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: web-ing
  annotations:
    kubernetes.io/ingress.class: traefik
spec:
  rules:
    - host: web.local
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: web-svc
                port:
                  number: 80
  </code></pre>

  <div class="callout good">
    ğŸ’¡ Kubernetes applique le modÃ¨le dÃ©claratif Ã  tous les objets : Pods, Services, Volumes, Secretsâ€¦
  </div>

  <h2>5ï¸âƒ£ â€“ La virtualisation au service de lâ€™orchestration</h2>

  <p>
    <strong>Objectif :</strong> comprendre comment la virtualisation soutient
    lâ€™orchestration et garantit isolation, Ã©lasticitÃ© et abstraction des ressources.
  </p>

  <div class="mermaid">
    flowchart TB
      A[Infrastructure physique] --> B[Machines virtuelles]
      B --> C[Cluster Kubernetes]
      C --> D[Pods / Services / Ingress]
  </div>

  <h3>âš™ï¸ Virtualisation et orchestration : dÃ©pendance</h3>
  <ul>
    <li>La virtualisation isole les nÅ“uds (VM = unitÃ© matÃ©rielle du cluster).</li>
    <li>Elle fournit la flexibilitÃ© : crÃ©ation/suppression dynamique des nÅ“uds.</li>
    <li>Elle permet Ã  Kubernetes de scaler et migrer ses workloads.</li>
  </ul>

  <h3>ğŸ’» Exemple selon lâ€™environnement</h3>
  <ul>
    <li><strong>Local :</strong> MicroK8s/Minikube sâ€™exÃ©cutent dans des VMs.</li>
    <li><strong>Cloud :</strong> Kubernetes sâ€™appuie sur EC2, GCE, Azure VM, OpenStackâ€¦</li>
  </ul>

  <div class="callout info">
    ğŸ’¡ Virtualisation = base matÃ©rielle ; Conteneurisation = unitÃ© logique ; Orchestration = pilotage global.
  </div>

  <h3>ğŸ§  ComplÃ©mentaritÃ© des couches</h3>
  <table>
    <thead>
      <tr><th>Niveau</th><th>Technologie</th><th>RÃ´le</th><th>Exemples</th></tr>
    </thead>
    <tbody>
      <tr><td>MatÃ©riel</td><td>Virtualisation</td><td>Isolation matÃ©rielle</td><td>KVM, VMware, Hyper-V</td></tr>
      <tr><td>SystÃ¨me</td><td>Conteneurisation</td><td>Isolation des processus</td><td>Docker, LXC</td></tr>
      <tr><td>Application</td><td>Orchestration</td><td>Ã‰tat dÃ©sirÃ©, scaling, rÃ©silience</td><td>Kubernetes</td></tr>
    </tbody>
  </table>

  <h3>ğŸ—ï¸ HiÃ©rarchie de clusters : du laptop Ã  la production</h3>
  <ul>
    <li><strong>P0</strong> â€” Dev local : MicroK8s/Minikube, 1 nÅ“ud, stockage local.</li>
    <li><strong>P1</strong> â€” Single cluster : 3 nÅ“uds VM, Ingress HA.</li>
    <li><strong>P2</strong> â€” HA rÃ©gionale : autoscaling, registry privÃ©, CSI managÃ©.</li>
    <li><strong>P3</strong> â€” Multi-clusters : GitOps global, fÃ©dÃ©ration inter-rÃ©gion.</li>
  </ul>

  <div class="mermaid">
    flowchart TB
      subgraph P0["P0 â€” Dev local"]
        A["MicroK8s (1 node)"]
      end
      subgraph P1["P1 â€” Single cluster"]
        B["Control Plane + Node pool"]
      end
      subgraph P2["P2 â€” HA rÃ©gionale"]
        C1["Control Plane HA"]
        C2["Pools de nÅ“uds autoscalÃ©s"]
      end
      subgraph P3["P3 â€” Multi-clusters"]
        D1["Cluster A"]
        D2["Cluster B"]
      end
      A --> B --> C1 --> D1
      C1 --> D2
  </div>

  <div class="callout good">
    ğŸ’¡ Message clÃ© : MicroK8s = mÃªme API que la prod, seule lâ€™Ã©chelle et la rÃ©silience changent.
  </div>
</section>
